using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Pathfinding;

public class FoodGen : MonoBehaviour
{

    /// <summary>
    /// To generate the food I'm using the  path which is generated by the seeker I did this as the path avoids all obstacles
    /// and I could easily traverse through the list (path.vectorpath) to generate the food 4 blocks away from each other and
    /// the head of the snake 
    /// </summary>
   

    GameObject Player;  // Player GameObject
    GameObject Target; // Target GameOnbject
    GameObject food; // Food Gameobject
    
    GameObject AIS;
    Seeker seeker; // Getting Seeker

    List<GameObject> foodKist = new List<GameObject>(); // List which hold the food gameobject

    Path pathToFollow; // The path which is generated by A *


    int indexSpawnFood = 4; // The index used in the pathtofollow to generate the food more than 4 blocks away from each other

    bool produceFood = true;

    

    // Start is called before the first frame update
    void Start()
    {

        Target = GameObject.Find("Diamond"); // Getting the target gameobject 
        seeker = GetComponent<Seeker>(); //Getting the seeker 

      


        StartCoroutine(checkFood());
        StartCoroutine(generatefood(true));
        StartCoroutine(createAI());

    

    }

    // Update is called once per frame
    private void Update()
    {
        foodEater();
        StartCoroutine(AIeat());


    }



    IEnumerator checkFood()
    {
        yield return new WaitForSeconds(0.1f);

        Player = GameObject.Find("Player"); // Getting the player
        print(Player.transform.position);

        pathToFollow = seeker.StartPath(Player.transform.position, Target.transform.position); // setting the path between the player and the target object
        Player.GetComponent<SpriteRenderer>().color = Color.red; // setting the player colour

        print("Transforms: " + Player.transform.position + "Waypoints: " + Target.transform.position);

        yield return seeker.IsDone(); // Wait for the seeker to be done before continuing 
        print("CheckFoodRun");

    }

  


    IEnumerator generatefood(bool loop)
    {

        yield return new WaitForSeconds(0.2f);
        List<Vector3> posn = pathToFollow.vectorPath; // Creating a list of type vector 3 to store the path 
        print(posn.Count + "Count");

       

                for (int i = 0; i <= posn.Count; i++) // looping throught the path list created by the seaker 
                {

                    print(posn[i] + "printing for posn[i]");
                    food = Instantiate(Resources.Load<GameObject>("Square"), posn[i + indexSpawnFood], Quaternion.identity); //Instantiting the food game object
                    food.GetComponent<SpriteRenderer>().color = Color.green; // Setting its colour to green 
                    foodKist.Add(food); // Adding the food game object to the food list. 
                    print(posn[i + indexSpawnFood] + "printing for posn[i+4]");
                    print(i + indexSpawnFood + "index posn");
                    print(posn.Count + "size of posn");
                    print(i + "this is the i value posn");
                    indexSpawnFood += Random.Range(4, 6);// Adding to our index so that the food spawns a min of 4 blocks away up to 10 blocks away. 
                    food.name = "Food"; // setting the name for the food  in the inspector
                    yield return new WaitForSeconds(0.1f);
              

                    if (foodKist.Count >= 6) // Generating 6 blocks of food
                    {
                        yield break;
                    }

                
            
        }

        yield return null;
    }


  void  foodEater()
    {

        print(foodKist.Count + "foodlistCounterman");
        

        if (foodKist != null) // count has to be larger then one meaning that the list is not empty
        {
            print("food count" + foodKist.Count);


        
            for (int hdj = foodKist.Count-1; hdj >=0; hdj--) // traversing the list top to bottom as if you traverse it bottom to top an
                                                             // error  occurs as you cannot traverse a list top to bottom while deleting the bottom value
            {
       
                print(hdj + "prost");
                print(foodKist[hdj].transform.position + "prost0");

                float dist = Vector3.Distance(Player.transform.position, foodKist[hdj].transform.position); // taking the distance from the player to the food
                print(dist + "distance of final one");

                if(dist <= 2 && foodKist !=null) // if this distance is reached
                {
                    if(foodKist[hdj] != null) // and the food at that index is not null
                    {
                        Destroy(foodKist[hdj]); // destroy that food 
                        foodKist.Remove(foodKist[hdj]); // remove the food from the list 
                        GameManager.snakeLength += 1; // increase the snake length by 1   
                    }
                }// taking the distance from the player to the food


            
            }

        }

    }


   IEnumerator createAI()
    {

        yield return new WaitForSeconds(3f);

      

        if (foodKist != null && GameManager.inlvl2 )
        {
            int ranNum = Random.Range(0,foodKist.Count-1);

            AIS = Resources.Load<GameObject>("AIS");

            AIS=Instantiate(AIS, foodKist[ranNum].transform.position, Quaternion.identity);

            Destroy(foodKist[ranNum]);

            foodKist.Remove(foodKist[ranNum]);



        }

     

            

    }




    IEnumerator AIeat()
    {
        yield return new WaitForSeconds(5f);

        if (GameManager.inlvl2 && foodKist != null)

        {


            for (int hdj = foodKist.Count - 1; hdj >= 0; hdj--) // traversing the list top to bottom as if you traverse it bottom to top an
                                                                // error  occurs as you cannot traverse a list top to bottom while deleting the bottom value
            {
                float dist2 = Vector3.Distance(AIS.transform.position, foodKist[hdj].transform.position); // taking the distance from the player to the food
                print(dist2 + " Enemy dist");

                if (dist2 <= 2 && foodKist.Count != 0) // if this distance is reached
                {

                    if (foodKist[hdj] != null) // and the food at that index is not null
                    {
                        print("eaten");
                        Destroy(foodKist[hdj]); // destroy that food 
                        foodKist.Remove(foodKist[hdj]); // remove the food from the list 
                        AIEnemySpawn.enemyLength += 1; // increase the snake length by 1   
                    }


                }// taking the distance from the player to the food
            }

        }

        yield return null ;

    }
}

   /*

    IEnumerator checkFoodpos() {


        while(true)
        {
            foreach (GameObject p in ovs)
            {
                float dist = Vector3.Distance(p.transform.position, food.transform.position);
                print("Distance: "+dist);

                if (dist > 3f)
                {
                    food = Instantiate(Resources.Load<GameObject>("Square"), new Vector3(Random.Range(9f,-9f), Random.Range(9f, -9f)), Quaternion.identity);
                    food.GetComponent<SpriteRenderer>().color = Color.green;
                }
                else
                {

                  

                }
                yield return  new WaitForSeconds(2f);


            }

        }
     





    }


    


   bool ObstExists() // comparing postion to check with our pastPosition list
    {


        foreach (GameObject p in ovs) // traversing the pastPositions list 
        {
            print("Obstacle" + p.transform.position + "to check" + food.transform.position);

            if (p.transform.position == food.transform.position) // if the p.postions matches the postionToCeck
            {
               
              print("Hittt");

            }

            print("ovs(p)" + p.transform.position);
            print("Checking Green Box" + food.transform.position);
        }
      
        print("Obstaclii not hittt");

        return false;
    }

    */


